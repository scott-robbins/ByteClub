# Nested
Alright so it appears as if there's one python file and two odd text files when you look at this project. The file is actually segments of python code
that has been base64 encoded, compressed and finally encrypted with AES. 

So here's the mess. On the left is the first file called ```utils.py``` which is generated by the function on the right, create_utils().

![src](https://raw.githubusercontent.com/scott-robbins/ByteClub/master/BadIdeas/yikes.png)

This python file contains the methods required for encrption and decryption. So the next terrible idea is to import this utils.py module (which didn't exist when test.py started running) to decrypt module.lol and build the primary python code as module.py. 

Here's the main method of the single python function appearing in the source. We see the creation and import of the utils is the first thing to happen. And then there is an option to encrypt a file base on input args (more on that later). 

![main](https://raw.githubusercontent.com/scott-robbins/ByteClub/master/BadIdeas/bad.png)

Next the code uses the utils previously unpacked to decrypt the main python module (also then built and imported). After that the code starts to achieve it's true objective. If it sees it is on a linux system it starts doing some
commandline scripting to pull external IP and geolocaiton information. 

Function names have been left somewhat obviously named in test.py, so the user might be able to inspect source and be confused but had these function names also been obscured test.py truly would have a set of functionality that is quite difficult to anticipate from inspecting the source/project before hand. 

